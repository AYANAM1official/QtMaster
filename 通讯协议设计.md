# 协议设计

## 1\. 协议设计原则

  * **人类可读 (ASCII)**：不要用二进制（0x01, 0xFE...），调试时直接在串口助手里就能看懂。
  * **行结构**：每一条消息都以换行符 `\n` 结尾，利用 Python 的 `readline()` 特性。
  * **键值对**：采用 `CMD:指令类型,键1:值1,键2:值2` 的格式，扩展性强，不怕数据顺序变动。

-----

## 2\. 详细协议定义

我们要定义的格式模版如下：
`CMD:类型,参数1:值1,参数2:值2...\n`

### (1) STM32 -\> 电脑 (上行数据)

| 场景 | 原始数据示例 (字符串) | 说明 |
| :--- | :--- | :--- |
| **商品结算** | `CMD:REPORT,ID:6912345` | **REPORT**: 上报销售记录<br>**ID**: 商品条码<br>|
| **紧急报警** | `CMD:ALARM,LEVEL:1,MSG:Fire_Error` | **ALARM**: 报警<br>**LEVEL**: 等级(1一般, 2严重)<br>**MSG**: 错误简述 |
| **请求同步** | `CMD:REQ_SYNC` | 下位机告诉电脑：“我的商品表旧了，请发新的给我” |

### (2) 电脑 -\> STM32 (下行数据)

| 场景 | 原始数据示例 (字符串) | 说明 |
| :--- | :--- | :--- |
| **模拟扫码** | `CMD:SCAN,ID:6912345678` | 假装电脑是扫码枪，把读到的条码发给 STM32 处理 |
| **开始同步** | `CMD:SYNC_START` | 告诉 STM32：准备好接收大量数据，暂停其他业务，擦除旧表 |
| **发送商品** | `CMD:SYNC_DATA,ID:691,PR:3.0,NM:Cola` | 逐条发送：条码、价格、名称(尽量用英文以免编码问题) |
| **结束同步** | `CMD:SYNC_END` | 告诉 STM32：发完了，恢复正常运行 |

-----

## 3\. 为什么这样设计？

这种格式在 Python 中解析极度简单，只需要两行核心代码：

```python
# 假设 line = "CMD:REPORT,ID:6912345,PR:3.50,QT:2\n"

# 1. 去掉换行符并按逗号分割
parts = line.strip().split(',')
# 结果: ['CMD:REPORT', 'ID:6912345', 'PR:3.50', 'QT:2']

# 2. 转成字典 (Dictionary)
data = {}
for part in parts:
    key, value = part.split(':')
    data[key] = value

# 结果: {'CMD': 'REPORT', 'ID': '6912345', 'PR': '3.50', 'QT': '2'}
```

这样你就可以直接用 `if data['CMD'] == 'REPORT':` 来写业务逻辑了，非常优雅。

-----

## 4\. 关键点提示 (STM32 端实现建议)

虽然你暂时不需要 STM32 代码，但我得提醒你两个坑，方便你后续写下位机：

1.  **发送频率**：
    电脑向 STM32 发送商品表（同步）时，速度会非常快。STM32 写 Flash 或 EEPROM 很慢。

      * **解决思路**：电脑端发送时要在每条数据间加 `time.sleep(0.05)`（50毫秒延时），或者让 STM32 每收一条回一个 `OK`，电脑收到 `OK` 再发下一条（应答模式）。建议先用简单的**延时法**。

2.  **中文编码**：
    STM32 通常使用 GBK 或 UTF-8，而 Python 3 默认全是 UTF-8。

      * **建议**：商品名称如果包含中文，**双方统一使用 UTF-8**。
      * *Python端*：`ser.write(cmd_str.encode('utf-8'))`
      * *STM32端*：确保你的串口调试助手或显示屏支持 UTF-8，或者在 Python 端发送前转码为 GBK (`.encode('gbk')`)。

-----

## 5\. 你的任务

如果这个协议你觉得没问题（特别是字段够不够用），我们就可以直接基于这个协议写 Python 代码了。

**你需要我根据这个协议，直接生成那个核心的 `ProtocolParser`（协议解析器）类和 UI 框架代码吗？**
